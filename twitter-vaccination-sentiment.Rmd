---
title: "Twitter Vaccination Sentiment Analysis"
author: "Alexandra Stephens"
output:
  html_document:
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE, warnings=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Motivation
Vaccines have had critics from the beginning of development. However, recently in the United States and around the world, vaccination has faced increasing skepticism and vaccination rates have begun to decline. Anti-vaccination rhetoric is especially prevalent on social media, where the platforms serve as an open space for misinformation to spread.

The goal of this study is to download Twitter data and identify tweets as pro-or-anti-vaccination. Tweets often have an associated location, thus this would allow researchers to locate communities where anti-vaccination sentiment is growing. This could help healthcare professionals identify communities that are at higher risk of infectious diseases.

In this document, we will provide start-to-finish methods on how to identify Twitter users and tweets that are "anti-vaccination."

<center>
![](data/map1.png)
</center>
This case study consists of data exploration and visualization using Natural Language Processing techniques, a social network analysis with the `igraph` package, and a sentiment analysis of the results.

The libraries used in this study are listed in the following table, along with their purpose in this particular case study:

|Library|Purpose|
|---|---|
|`stringr`|Parsing text with regular expressions|
|`tidytext`|Loading important datasets and manipulating text data|
|`dplyr`|Dataframe manipulation|
|`ggplot2`|Plotting sentiment|
|`wordcloud`|Creating wordcloud visuals|
|`SnowballC`|Word stemming|
|`igraph`|Performing social network analysis|
|`threejs`|Graphing large-scale social networks (compatible with `igraph`)|
|`visNetwork`|Graphing social networks with labels|

In order to run this code please ensure you have these packages installed. 

If you would like to download your own Twitter data, you will need to sign up for a Twitter developer account, create an application, and enter your own keys & credentials in the "What is the data?" section below.

The learning objectives include data cleaning and manipulation with natural language processing and regular expressions, social network analysis, semi-supervised learning concepts, and sentiment analysis.

# What is the data?
To collect data from Twitter, we suggest using the `rtweet` package. Again, if you would like to download your own Twitter data, you will need to sign up for a Twitter developer account, create an application, and enter your own keys below. We've set the code chunk `eval = false` so that when the entire file is knit the code in the chunk is ignored.

```{r eval=FALSE}
library(rtweet)

twitter_token <- create_token(
  app = "twitter_app_name",
  consumer_key = "XXXXXXXXXXXXXXX",
  consumer_secret = "XXXXXXXXXXXXXXXXXXXXX",
  access_token = "XXXXXXXXXXXXXXXXXXXXXXXXXXX",
  access_secret = "XXXXXXXXXXXXXXXXX")
```
Once the `twitter_token` is create it is stored in the work space and you are free to use all the functions in `rtweet`!

The `search_tweets` function can download 18,000 every 15 minutes (with the free developer account). However adding `retryonratelimit = TRUE` automatically waits for the rate limit to be reset (after 15 min) and then searches for the remaining tweets. This is repeated until all requested tweets are downloaded.

We search for the 18,000 most recent tweets (`type = "recent"`) that contain the hashtags "antivax" or "vaccineswork", as well as just the word "vaccines". `include_rts = TRUE` means we are including retweets. This is important for this case study: we want to be able to connect users to one another if they share the same opinion. We can assume if a user retweets a tweet without adding any text to it (which might state their opposition to the tweet) then they agree with the tweet.

We set `lang = "en"` to capture only tweets in English.

```{r eval=FALSE}
st <- search_tweets('#antivax OR vaccines OR #vaccineswork', 
                    n = 18000,
                    type = "recent",
                    include_rts = TRUE, 
                    lang = "en")
```
After collecting the tweets with the `rtweet` package, we exported the data as a csv file. This is an important step because the data you collect with the API can be very different every time. It also takes a few minutes to download new tweets.

Before exporting as a CSV we removed the rows that 
```{r eval=FALSE}
for (col in colnames(st))
  {
  if (typeof(st[[col]]) == "list")
    {
    st[[col]] <- NULL
  }
}
```
Next, we'll import a set of data that was created with the exact steps as above.

# Data import
Before doing anything, we should load the libraries needed for the case study.
```{r, message = FALSE}
library(kableExtra)
library(stringr)
library(lexicon)

library(tidytext)
library(dplyr)
library(ggplot2)
library(kableExtra)
library(tidyr)
library(tm)
library(topicmodels)

library(wordcloud)
library(SnowballC)

library(topicmodels)

library(igraph)
library(threejs)
library(visNetwork)
```

Now we upload the data as a dataframe with `read.csv` and look at all the fields/features/columns by printing out the `colnames`. Each row of the dataframe is information about *one tweet*. We also print out the first row with `head(tweets_df,1)` to get an idea of what kind of information is in each row and column.
```{r}
tweets_df <- read.csv("data/date02_13_n5k_key3_uuidgens_final.csv",
                      stringsAsFactors = FALSE,
                      encoding="UTF-8")
colnames(tweets_df)
head(tweets_df,1)
```
In a separate file, unique IDs were generated for each user so that all identifiers could be removed in order to avoid assuming or exploiting any political or religious views and/or the state of someone's health.

We describe a few of the important columns in the following table:

For each row $i$,

|Column|Description|
|--|---|
|`text`|Raw text from tweet $i$|
|`uuidgens_user`|Unique ID of the user who tweeted (or retweeted) tweet $i$|
|`uuidgens_retweet`|Unique ID of the user that tweet $i$ was *retweeted from*|
|`created_at`|Date and time tweet $i$ was tweeted|
|`display_text_width`|Number of characters in tweet $i$|
|`location`|Location the tweeting user has listed in their Twitter bio|
|`description`|Description the tweeting user has listed in their Twitter bio|
|`long` and `lat`|Longitude and latitude coordinates|


# Data wrangling
## Cleaning with regular expressions
Using regular expressions to parse and clean text is an important skill when dealing with text data. Let's take a look at the data to see what we need to clean by printing the head, or first 6 lines, of the `text` column - the raw text from the tweets we downloaded.

```{r}
head(unique(tweets_df$text),10)
```

From this small peak at the data, we can already see that there are a lot of strings that are not real words. We should remove text that does not help and, in fact, may hinder our analysis. For example, we observe lots of links ("https...") and UTF characters ("\\U000...") that aren't giving us any insightful information.

To do this, first we create a string named `pat` (short for *pattern*) that contains *regular expression* or "regex" patterns that match with various unwanted characters or phrases.

```{r}
pat <- "[\r\n]|&amp.|@.*?[ \t\r\n]|@.*?$|https:.*[ \t\r\n]|https:.*$|[^[:alpha:][ \t\r\n]?&/\\-#.']"
```

Note that the "|" character separates each pattern the string. For example, the first pattern `[\r\n]` matches with newline characters, and is followed by a "|" to signify the end of that regular expression.

Let's break down each of the strings in `pat` and explain what text it is meant to match with

|Regex Phrase|Text match|
|---|---|
|`[\r\n]`|Carriage returns and newline characters|
|`&amp.`|"&amp" phrase|The "." matches any character|
|`@.*?[ \t\r\n]`|Tagged user handle followed by white space (already done)|
|`@.*?$`|Tagged user handle at the end of the tweet (already done)|
|`https?:.*[ \t\r\n]`|Embedded link followed by white space|
|`https?:.*$`|Embedded link at the end of the tweet|
|`[^[:alnum:][:blank:]?&/\\-#.]`|Remove UTF-8 strings but keep any "?&/\\-#." characters|

Let's break down one of the above patterns, `@.*?[ \t\r\n]`, to see how regular expressions work.

First, `@` simply matches with the @ sign, the beginning of tagging a user on Twitter. In regular expression "." can match with any character except for newline `\n`. The "`*`" character matches 0 or more of the previous character, which in the case below is the "." or any character. So now we have matched with anything beginning with @. The "?" quantifier is *non-greedy*, meaning it matches as few characters as possible. We want to include this so that we remove the minimum amount of text and thus only the username tag. We stop removing text when we reach a space, tab, carriage return or newline character, `[ \t\r\n]`. Thus, `@.*?[ \t\r\n]` matches with any username that is retweeted or tagged.

Now we will remove the string that match with these patterns with `str_replace_all`. It checks for matches with *every seperate pattern* in `pat` and looks for repeats of any pattern (hence, the addition of `_all`. Each match is replaced with an empty string, `""` and thus the unwanted string is removed.

We replace the `tweets_df` columns `text` and `retweet_text` with the cleaned versions of the columns by using `mutate`. Then we print the head of the `text` column to view our changes.


```{r}
tweets_df <- tweets_df %>% 
  mutate(text = str_replace_all(text, pattern = pat, "")) %>%
  mutate(retweet_text = str_replace_all(retweet_text, pattern = pat, "")) %>%
  
  mutate(text = str_replace_all(text, pattern = "  ", " ")) %>%
  mutate(retweet_text = str_replace_all(retweet_text, pattern = "  ", " "))

head(unique(tweets_df$text))

```
Now that the raw tweet text is clean, let's start manipulating the tweets with natural language processing techniques to gain insight about our data.

## The tidy text and NLP

The tidy text format is using **one-token-per-row** in our dataframe. In short, tokens in natural language processing are words. To be technical, you could say a token is a list of characters between two spaces. Tokenization is the process of breaking up a string, paragraph, or document into tokens.

We want to tokenize our tweets, however we don't want to lose any information. Specifically, we want to keep track of what Tweet each word came from since our analysis involves differentiating tweets. Other analyses including topic summarization may not require keeping track of this--you can just a create a jumble (i.e. "corpus") of words and find commonalities.

In the code chunk below, we first create the dataframe `text_df` with the `tweets_df` column `text` and add the `int` column as an index for the tweets. Then, we tokenize the text data with tidytext's `unnest_tokens` by using the `text` column as the input and `word` as the name of the output column. We replace `text_df` with this newly formatted dataframe.

```{r}
unique_indices <- order(tweets_df$text)[!duplicated(sort(tweets_df$text))]

text_df <- data.frame("text" = tweets_df$text[unique_indices])
text_df$int <- as.numeric(unique_indices)
      
text_df$text <- as.character(text_df$text)


text_df <- text_df[order(text_df$int),]
row.names(text_df) <- 1:nrow(text_df)

head(text_df)

text_df <- text_df %>%
  unnest_tokens(word, text)

head(text_df)

```
Now that we have our data in a "tidy" format, we want to remove stop words from the text. *Stop words* in NLP are common words that don't add value to a sentence, paragraph, document etc. For example, "still think the flu shot is..." doesn't give us any extra information than "still think flu shot," so we can remove these words to make our dataset more concise.

To do this, simply load the `stop_words` dataset, which has two columns: `word` and `lexicon`. There are three different lexicons that reference the *source* of the stop word:

- [onix](http://www.lextek.com/manuals/onix/stopwords1.html)

- [SMART](http://www.jmlr.org/papers/volume5/lewis04a/lewis04a.pdf)

- [snowball](http://snowball.tartarus.org/algorithms/english/stop.txt)

The difference between the lexicons is they include different words. Some include more than others, thus if we use these we remove more words and from our data. To quickly see these differences, we can count the number of stop words in each category using `dplyr::group_by`.
```{r}
data(stop_words)
head(stop_words)

stop_words %>% 
    group_by(lexicon) %>% 
    tally()
```

Since we have no prior reason to chose a specific lexicon, let's remove all of the stop words in the `stopwords` dataset from our data using the `anti_join` function. We can always modify this later on.
```{r}
text_df <- text_df %>%
  anti_join(stop_words %>% filter(lexicon == "snowball"))

head(text_df,10)
```
## Stemming
Another technique often used alongside removing stopwords is word *stemming*. Stemming changes each word to a root word so that different conjugations of the same word are not treated as different words completely. A human can tell that "vaccine", vaccinate" and "vaccination" have close to the same meaning. However, for example, if we were to count every repetition of "vaccine" in R we would not get an accurate total since "vaccination" would be ignored. Instead, we change each of those words to "vaccin" with a stemming algorithm.

We will use the library `SnowballC` which implements the [Porter stemming algorithm](http://snowball.tartarus.org/algorithms/porter/stemmer.html).

```{r}
text_df_stemmed <- text_df %>%
  mutate(word = wordStem(word))
head(text_df_stemmed,10)
```
Since we've filtered and removed the most common english words, let us also remove the most *uncommon* words in our dataset. This helps reduce the size of our data and remove meaningless words.
```{r}
temp <- text_df_stemmed %>%dplyr::count(word)
head(temp)
uncomm_words <- temp %>% filter(n == 1) %>% select(word)
uncomm_words

text_df_stemmed_common <- text_df_stemmed %>%
  anti_join(uncomm_words)

nrow(text_df_stemmed)
nrow(text_df_stemmed_common)
```

# Exploratory data analysis

## Map visual
For a fun visual, we can visualize our tweets on a map. First let's find which tweets use the word or hashtag "antivax" and which tweets say "vaccines work." Next we add the column `Hashtags` that contains labels for if the tweet contains these words or contains neither.
```{r}
anti_lst <- as.numeric(
  grepl("antivax", tweets_df$text))
pro_lst <-as.numeric(
  grepl("vaccines work", tweets_df$text))

head(anti_lst)

tweets_df$Hashtags <- "none"
tweets_df$Hashtags[anti_lst == 1] <- "#antivax"
tweets_df$Hashtags[pro_lst == 1] <- "vaccines work"
```
Next we use `ggplot2` and `ggmap` to plot this on a map.
```{r}
states <- map_data("state")

ggplot(data = states) + 
  geom_point(data = tweets_df, aes(x = lng, y = lat,  colour = Hashtags), size = 1) +
  geom_polygon(aes(x = long, y = lat, group=group), fill = NA, color = "dark grey") +
  theme_void()
```

As we can there was sum missing data. This is expected since most people probably don't have their location turned on on twitter. We calculate exactly what percentage of tweets do not have an associated latitude and longitude below.
```{r}
sum(is.na(tweets_df$lat) ==FALSE)/dim(tweets_df)[1]*100
```
## N-grams
A common NLP data exploration practice is looking at n-gram frequencies.
*N-grams* are sequences of *n* items/tokens. Common n-grams that are used in NLP are unigrams, bigrams, and trigrams, meaning one word, two word, and three word combinations.

We find the top 10 most common words or unigrams to see common topics in our data. Recall that we have already removed stopwords and unnecessary items such as web links, and we have stemmed the remaining words.

```{r}
unigram_count <- text_df_stemmed %>% dplyr::count(word, sort = TRUE)
head(unigram_count,20)
```
We can graph the unigram frequencies with ggplot for a nice visualization of our text data. We pick a number of appearances to filter smaller than the total tweets we have (5,000) to plot only the top few words.
```{r}
unigram_count %>%
  filter(n>100) %>%
  mutate(word = reorder(word, n)) %>%
  ggplot(aes(word, n)) +
  geom_col() +
  xlab(NULL) +
  ylab(NULL) +
  coord_flip()
```

Next, we can look at common *bigrams*, which are two words in a row. The tidytext function `unnest_tokens` is an efficient way to find bigrams by setting `token = "ngrams"` and `n = 2`. The output column is named "bigram".

To get the most frequent bigrams we can simply use the `dplyr` library's `count` function again.
```{r}
bigrams_stemmed <- text_df_stemmed %>%
  unnest_tokens(bigram, word, token = "ngrams", n = 2)

head(bigrams_stemmed)

head(bigrams_stemmed %>%
  dplyr::count(bigram, sort = TRUE),10)
```

Last in this section, a fun exploration graphic of unigrams is a "word cloud." We can create this data visualization easily with the `wordcloud2 `.
```{r}
unigram_count %>%
  with(wordcloud(word, n, max.words = 100))
```

## Sentiment
We want to classify the tweets by sentiment, or rather by the feelings and emotions portrayed by the user. As humans we can easily tell if someone is angry, sad, satisfied, or even sarcastic. However we have to give the computer some clues on how to do this start with the `sentiments` dataset which is loaded with the `tidytext` library. Similar to the `stop_words` dataset, there are three lexicons:

* `afinn` gives each word an integer score between -5 and 5, from most negative to most positive sentiment.

* `bing` gives a binary "negative" or "positive" sentiment to each words.

* `nrc` assigns sentiment labels of "positive, negative, anger, anticipation, disgust, fear, joy, sadness, surprise, and trust."

We can also use the tidytext's `get_sentiments()` function to only get data from a particular lexicon.

```{r}
head(sentiments)
head(get_sentiments('afinn'))
```
"How were these sentiment lexicons put together and validated? They were constructed via either crowdsourcing (using, for example, Amazon Mechanical Turk) or by the labor of one of the authors, and were validated using some combination of crowdsourcing again, restaurant or movie reviews, or Twitter data. Given this information, we may hesitate to apply these sentiment lexicons to styles of text dramatically different from what they were validated on, such as narrative fiction from 200 years ago. While it is true that using these sentiment lexicons with, for example, Jane Austenâ€™s novels may give us less accurate results than with tweets sent by a contemporary writer, we still can measure the sentiment content for words that are shared across the lexicon and the text."
(note to self)

Next let's merge some of our data with the sentiment lexicon "afinn" to explore our text.
```{r}
nrc_example <- get_sentiments("afinn") %>% 
  filter(score == -2)

head(text_df %>%
  inner_join(nrc_example) %>%
  dplyr::count(word, sort = TRUE),10)
```
We note that sentiment analysis would not be straight-forward. From the text printed above, we can't exactly pinpoint if the user is being negative about vaccinations, or the effects of not getting vaccinated, or just being negative about the anti-vaccination or vaccination communities.

Let's plot the average `afinn` scores for each tweet to explore the overall sentiment of our data.

```{r,message=FALSE}
library(tidyr)
head(text_df)

tweet_sentiment <- text_df %>%
  inner_join(get_sentiments("afinn")) %>%
  dplyr::group_by(int) %>%
  dplyr::mutate(text = paste0(word)) %>%
  dplyr::summarize(sentiment_mean = mean(score))

tweet_sentiment_ordered <- tweet_sentiment[order(tweet_sentiment$sentiment_mean),] 

tweet_sentiment_ordered$int <- factor(tweet_sentiment_ordered$int, levels = tweet_sentiment_ordered$int)

ggplot(tweet_sentiment_ordered, aes(sentiment_mean)) +
  geom_histogram(show.legend = FALSE, binwidth = .3) +
  ggtitle("Mean afinn sentiment score per tweet") + 
  geom_vline(xintercept = 0, linetype = "dashed", colour = "red") +
  ylab(NULL)
 # #facet_wrap(~book, ncol = 2, scales = "free_x")


```
Remember when we said we should consider the negation issue? As in, how can we distinguish between the sentiment of "not like" and "like"?

Let's print out some positive tweets. We can use the index column "int" that we've kept constant to print out the original (sans and Twitter handles) tweets.

```{r}
positive <- tweet_sentiment$int[tweet_sentiment$sentiment_mean > 2]
head(tweets_df$text[positive])
```
And let's look at some negative ones as well..
```{r}
negative <- tweet_sentiment$int[tweet_sentiment$sentiment_mean < -2 ]
head(tweets_df$text[negative])
```
Neither the positive nore negative tweets are unanimously on either side of this "issue", even with this small sample of text. Now we can really see how this won't be easy!

We should think about what we can do about the words that won't be found in the `sentiments` dataset, like "#vaccineswork" that might give us even more information about whether or not the tweet is supporting vaccines or not.

Sentiment may be just a small part of clustering tweets as "pro-vaccination" or "anti-vaccination."

http://www.public.asu.edu/~huanliu/papers/sbp14.pdf

# Data analysis

## Topic Modeling
Since our data is unsupervised, meaning we don't have any prior knowledge or labels to tell us if a tweet is pro or anti vaccine, we want to use topic modeling to seperate the tweets into the two sides using only the text. 

Latent Dirichlet allocation (LDA) is common topic modeling method: it views each document (or in our case, each tweet) as a mixture of topics, and each topic as a combination of words. A word can be part of multiple topics, thus allowing some overlap.

In order to apply LDA, we need to take our cleaned and "tidy" text data `text_df` and turn it into a *document term matrix* (DTM). It is easy to convert from the tidy text format to this matrix. First, we add a column counting the number of word repeats per tweet.
```{r}
dtm_df <- text_df_stemmed_common %>%
  group_by(int, word) %>%
  tally()

head(dtm_df)
```
Next, we simply use the command `tidytext::cast_dtm` to convert to a document term matrix, a structure where each row is a document and each column is a word.
```{r}
(text_dtm <- dtm_df %>%
  cast_dtm(int, word, n))

head(Terms(text_dtm))
head(Docs(text_dtm))
```
Now we are ready to apply LDA to our DTM. We set `k=2` because we are trying to create two categories of tweets: pro and anti vaccination. However, we should consider trying 3 categories later, the third being "other" tweets that are irrelevant to the debate. Note that we have no control over whether these will be the two or three clear categories, but it is the goal we are trying to achieve.

We also set an arbitrary seed to ensure we recreate the same results each time we run the code.
```{r}
(lda_k2 <- LDA(text_dtm, k = 2))#, #control = list(seed = 1234)))
```
Now that we have our model results, we must do some exploring in order to interpret them.

As mentioned previously, each word can be in multiple topics. To examine the probability that a certain word belongs to one of the topics, we can retrieve the "beta" values. This can be done easily by providing the function `tidy` our topic model.
```{r}
topics_k2 <- tidy(lda_k2, matrix = "beta")
head(topics_k2)
```
Notice this dataframe is again in the "tidy" format with one word/topic per row.

We can plot the most probable words for each topic by first creating a dataframe with the top 15 words for each topic.

Then we sort by the top terms and plot the data with `ggplot2`. In this case we filter by topic to show the differences.
```{r}
top_terms <- topics_k2 %>%
  group_by(topic) %>%
  top_n(10, beta) %>%
  ungroup() %>%
  arrange(topic, beta)

top_terms %>%
  mutate(term = reorder(term, beta)) %>%
  ggplot(aes(term, beta, fill = factor(topic))) +
  geom_col(show.legend = TRUE) +
  coord_flip()
```

Some words overlap in each topic, but this is okay (and even good) because we know words such as "vaccine" can be used by both sides of this debate.

To look at the most polarizing words, i.e. words with the greatest difference between the beta values for topic 1 and 2 we can take the log ratio. We filter the `topics_k2` tidy dataframe to only have common words by setting `topic_x > .001`.
```{r}
beta_spread <- topics_k2 %>%
  mutate(topic = paste0("topic_", topic)) %>%
  spread(topic, beta) %>%
  filter(topic_1 > .001 | topic_2 > .001) %>%
  mutate(log_ratio = log2(topic_1 / topic_2))

head(beta_spread,10)
```
Next we filter the log ratio to display just a few common terms with the largest differences between beta values. 
Note that since our log ratio is $log(\frac{topic_1}{topic_2})$, if the beta value for topic 1 is larger, the log ratio will be positive. Again this means that the particular word is more likely to fall in topic 1 instead of 2. The reverse is true (if $\beta_{t2} > \beta_{t1}$, then the log is negative).
```{r}
beta_spread %>% 
  filter(log_ratio > 4.5 | log_ratio< -4.5) %>%
  mutate(term = reorder(term, log_ratio)) %>%
  ggplot(aes(term, log_ratio)) +
  geom_col(show.legend = FALSE) +
  coord_flip()
```

Examine group probabilities by tweet

Now that we have examined the *beta* values, or probability a word is in each topic, we now look at the *gamma* $(\gamma)$ probabilities or "per-document-per-topic probabilities."

We create a new dataframe using `tidy()` again and observe how it is arranged: for each topic and document combination (for this dataset, each document is a tweet), there is a gamma value between 0 and 1. 

Next, we look at the tweets with the most extreme $\gamma$ values to get a sense of what we are working with.
```{r}
lda_tweets <- tidy(lda_k2, matrix = "gamma")
head(lda_tweets)

lda_tweets<-lda_tweets %>% arrange(desc(gamma))
head(lda_tweets)
```

This doesn't tell us that much until we actually read the tweets in relation to their assigned topics. 

Let's print the 20 tweets with the largest $\gamma$ scores,meaning they are the most skewed towards one topic or the other. We do this using the `kableExtra` library to make the twitter text nice and readable. We can also add a `scroll_box` to make a window that can be scrolled through when this file is knit to a HTML file.
```{r}
diff_tweets<-tweets_df$text[as.numeric(lda_tweets$document[1:20])]

diff_tweets<-data.frame(diff_tweets)
diff_tweets$topic <- as.numeric(lda_tweets$topic[1:20])

kable(diff_tweets) %>%
  kable_styling("striped", full_width = F) %>%
  scroll_box(width = "750px", height = "300px")
```
It's not obvious that there is a distinct difference between the two topic categories. In fact, there are some tweets that are clearly pro-vaccination in topic 2 but I also see some that are clearly anti-vaccination. This may be because this kind of topic modeling only looks at individual words such as "vaccine," and not at bigrams or trigrams such as "vaccines work" and "vaccines cause autism."

So let's run a similar analysis but instead of starting with the one-token-per-row format, we start with the `bigrams` dataframe we created earlier. Take a look at the dataframe we just used for our analysis compared to `bigrams`:
```{r}
head(text_df_stemmed_common)
head(bigrams_stemmed)
```
The format is quite similar. Let's proceed in converting `bigrams` to a document term matric (DTM).
```{r}
dtm_bigram_df <- bigrams_stemmed %>%
  group_by(int, bigram) %>%
  tally()

head(dtm_bigram_df)

(bigram_dtm <- dtm_bigram_df %>%
  cast_dtm(int, bigram, n))

head(terms <- Terms(bigram_dtm))
```

Now we apply LDA to this DTM as before.

This time, let's try using `k = 3` to see if we can capture the following three topics:

- Anti-Vaccination
- Pro-Vaccination
- Irrelvant/No Opinion


```{r}
(lda_bi_k3 <- LDA(bigram_dtm, k = 3, control = list(seed = 1234)))
```
We get the beta values as before.
```{r}
bigram_beta <- tidy(lda_bi_k3, matrix = "beta")
head(bigram_beta)
```

```{r}
bigram_gamma <- tidy(lda_bi_k3, matrix = "gamma")
bigram_gamma<-bigram_gamma %>% arrange(desc(gamma))
head(bigram_gamma)
```
Wow! These $\gamma$ values are much higher than when we used unigrams and 2 topics. Let's read the tweets to see how it did.
```{r}
diff_tweets<-tweets_df$text[as.numeric(bigram_gamma$document[1:20])]

diff_tweets<-data.frame(diff_tweets)
diff_tweets$topic <- as.numeric(bigram_gamma$topic[1:20])

kable(diff_tweets) %>%
  kable_styling("striped", full_width = F) %>%
  scroll_box(width = "750px", height = "300px")
```


## Social network analysis

Assuming that, with high probability, users do not change their views (especially within a 7-day window) we can label Twitter users and represent them as a *social network* to help classify tweets.

To do this, we will use the power of retweets. We use Retweets because we can assume that if a user retweets another users tweets about vaccination, they probably agree with their opinion. This assumption gets stronger as the social network grows more connections.

We will build a network using the `igraph` package. This network will have users as nodes or vertices, with an edge between two vertices if the users retweet the same tweet, are following or are friends with the other user, or retweeted a tweet directly from the other user. The weight of the edge will increase if more than one of the previous are true.

First, we should create a data frame where the first two columns are vertices with an edge between them. 

add attributes if there are multiple connections necessary.

```{r}

tweets_df <- tweets_df %>% 
  mutate(tweet_factor = 
           as.numeric(factor(text)) )

l <- list()

for (i in c(1:max(tweets_df$tweet_factor))){
  users <- unique(c(tweets_df$uuidgens_user[tweets_df$tweet_factor==i],
                    tweets_df$uuidgens_retweet[tweets_df$tweet_factor==i]))
  users <- users[is.na(users) == FALSE]
  l <- append(l, list(users))
}

```
Now we have each tweet on the list with the associated users. Now let's create an edge between all these users by creating the dataframe that will be converted to a graph object with `igraph`.
```{r}
graph_df <- matrix(ncol=2, nrow=400000)
index = 1

for (i in c(1:length(l))){
  if (length(l[[i]]) > 1){
    combos <- t(combn(l[[i]],2))
    graph_df[c(index:(index + length(combos[,1])-1)),] <- combos
    
    index = index + length(combos[,1]) 
  }
}

graph_df <- as.data.frame(graph_df)
```

Let's delete the extra room
```{r}
graph_df<-graph_df[is.na(graph_df$V1) == FALSE,]
dim(graph_df)
head(graph_df)
```

So now we've connect each user to all of its tweets, and each unique tweet to all unique users that retweeted it.
```{r}
graph_df$V1 <-as.character(graph_df$V1)
graph_df$V2 <-as.character(graph_df$V2)

graph_df <- graph_df %>%
  group_by(V1,V2) %>%
  tally()

dim(graph_df)

#df1 <- data.frame(t(apply(graph_df[1:2], 1, sort)), graph_df[3])
#df1 <- aggregate(n~., df1, FUN=sum)
```


```{r}
vtx_df <- data.frame("unique_vtcs" = unique(c(graph_df$V1, graph_df$V2)))
head(vtx_df)
```
Set remaining vertices to -1 so they are ignored (initialized vertices)
```{r}
g <- graph_from_data_frame(d = graph_df, directed = FALSE, vertices = vtx_df)
edge_width <- (E(g)$n)**2
```

Run label propagation, Add vertex attributes and color the largest communities.
```{r}
clp <- cluster_label_prop(g, weights = edge_width)#, fixed = vtx_df$fix)

# create some vertex attributes
V(g)$community <- clp$membership
head(E(g)$n)

#V(g)$betweenness <- betweenness(g, v = V(g), directed = F)
#V(g)$degree <- degree(g, v = V(g))
```
Data visualization: color the largest communities.
```{r}
data <- toVisNetworkData(g)
nodes <- data[[1]]
edges <- data[[2]]

edge_width <- (E(g)$n)**2

library(RColorBrewer)

get_big_coms <- nodes %>% 
  select(community) %>% 
  group_by(community) %>% 
  tally() %>%
  arrange(desc(n))

biggest_groups<- get_big_coms$community[1:2]

col <- rep("grey", length(V(g)))
colors<- brewer.pal(10, "Paired")

for(j in c(1:2)){
  col[V(g)$community == biggest_groups[j]] <- colors[j]
}
```

Now that we have created all the labels we can display the graph with `graphjs`.
```{r}
graphjs(g, vertex.color = col,  vertex.size = .3,  edge.width = edge_width, na.ok = TRUE)
```

# Summary of results
Here I will compare the results from the topic modeling to the social network approach. We will see if the same tweets were clustered into the same communities. We will map the results to see if there is a geographical trend.


